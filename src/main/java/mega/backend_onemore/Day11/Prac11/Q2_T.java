package mega.backend_onemore.Day11.Prac11;

import java.util.Scanner;

public class Q2_T {

  public static void main(String[] args) {
    Scanner sc = new Scanner(System.in);
    System.out.print("숫자 입력 : ");
    int num = sc.nextInt();

    // num x num 크기의 2차원 배열 생성
    int[][] arr = new int[num][num];

    int R = 0; // 행
    int C = -1; // 열
    int K = num; // 반복횟수
    int SW = 1; // 증가 감소를 위한 스위치
    int N = 1; // 값

    while(true) {
      //열에 대한 반복문
      for(int i = 0; i<K;i++) {
        C += SW; // 스위치에 따라 열 증가 또는 감소
        arr[R][C] = N++; // N 값으로 배열 요소를 채우고 N 값 증가
      }

      K--; // 한 반복 후 K 값 감소
      if(K == 0) { // K가 0이면 while 루프를 빠져나감
        break;
      }

      //행에 대한 반복문
      for(int j = 0;j<K;j++) {
        R += SW; // 스위치에 따라 행 증가 또는 감소
        arr[R][C] = N++; // N 값으로 배열 요소를 채우고 N 값 증가
      }

      SW *= -1;
      // 행 반복문을 마칠 때마다 스위치 값 변경하여 열과 행 반복문이 번갈아가며 실행
    }

    // 배열 출력
    for(int i =0;i<arr.length;i++) {
      for(int j = 0;j<arr[i].length;j++) {
        System.out.print(arr[i][j]+"\t");
      }
      System.out.println();
    }
  }

}
/*
풀이 IDEA
* 열이 증가하고 -> 행이 증가하고 / 또는, 열이 감소하고 -> 행이 감소하고 ... => 이 논리가 한 세트가 될 수 있다.
* 이 두 개가 하나의 쌍으로 동작한다.
* 한 번 반복 할 때마다 방향이 바뀌어야 한다.
** 방향 바꾸는 가장 간편한 방법이 switch를 이용하는 것!
(변수 선언해서 활용하는 방법이겠지.)

*** 이 sw는 부호를 바꾸는 역할만 수행하면 된다.

즉 열이 증가하고 -> 행이 증가하고 // 스위치 // 열이 감소하고 -> 행이 감소하고
이 로직.
반복 횟수를 나타내는 변수 k도 선언해서,
k--;를 반복이 끝날 때마다 해주고,
k==0 이 되면 break.

그런데 이 세트가 왜 가운데에 있는가?
열과 행이 하나의 세트인데, 그럼 행까지 끝나고 하면 되는 거 아니야??
=> 돌려보면, 마지막엔 필연적으로 행 증가 한 번만 남는다!

즉, 마지막인 경우를 고려하여...
열을 나타내는 int c 가 -1로 초기화된 이유는
정확한 반복문 시작을 위해서(어찌보면 끼워맞춘 코딩이라 할 수 있음.)
최초 위치의 c를 쓰기 전에, c를 sw에 1을 더한 상태로 시작을 하고 있음.

따라서 c의 시작이 -1 이어야 이 반복문이 제대로 돌아갈 수 있게 되는 것.
만약 c가 0이었으면 조건문이 따로 들어가야하니까.

그럼, 왜 행은 0으로 초기화했냐?
애초에 행은 시작 자체가 1이다.

예를 들어, 1 2 3 4 5 다음에 6 7 8 9 갈 때,
1 2 3 4 5가 끝나고 한 칸이 이동한 상태에서 6 7 8 9가 되잖아.
뭐 그런 느낌...
 */